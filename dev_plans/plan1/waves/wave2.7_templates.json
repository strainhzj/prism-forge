{
  "_file_type": "template_references",
  "_description": "Wave 2 ä»£ç æ¨¡æ¿å¼•ç”¨æ–‡ä»¶ï¼šæä¾›å®ç°æ‰€éœ€çš„å®Œæ•´ä»£ç æ¨¡æ¿",
  "wave_id": "WAVE_2",
  "name": "Wave 2 ä»£ç æ¨¡æ¿å¼•ç”¨",
  "version": "v6.0",
  "_version_description": "åŸºäº v6.0 è™šæ‹Ÿæ‰§è¡Œå¼•æ“ä¼˜åŒ–ï¼Œæ–°å¢ T2_008 (Settings æ¨¡å—) å’Œ T2_009 (migrate_v12) æ¨¡æ¿ï¼Œä¿®å¤ç¬¦å·å­¤å²›å’Œé…ç½®é—­ç¯é—®é¢˜",
  "_v6_0_improvements": {
    "symbol_reference_integrity_fix": {
      "title": "ç¬¦å·å¼•ç”¨å®Œæ•´æ€§ä¿®å¤ï¼ˆv6.0 æ–°å¢ï¼‰",
      "fixed_orphans": [
        {
          "symbol": "get_active_threshold()",
          "template": "T2_008",
          "file": "src-tauri/src/database/settings.rs"
        },
        {
          "symbol": "update_active_threshold()",
          "template": "T2_008",
          "file": "src-tauri/src/database/settings.rs"
        },
        {
          "symbol": "is_scan_cache_enabled()",
          "template": "T2_008",
          "file": "src-tauri/src/database/settings.rs"
        },
        {
          "symbol": "set_scan_cache_enabled()",
          "template": "T2_008",
          "file": "src-tauri/src/database/settings.rs"
        }
      ]
    },
    "configuration_closure_fix": {
      "title": "é…ç½®é—­ç¯å®Œæ•´æ€§ä¿®å¤ï¼ˆv6.0 æ–°å¢ï¼‰",
      "closed_loops": [
        {
          "config": "active_threshold",
          "storage": "âœ… Wave 1 migrate_v6",
          "read_function": "âœ… T2_008 get_active_threshold()",
          "write_function": "âœ… T2_008 update_active_threshold()"
        },
        {
          "config": "scan_cache_enabled",
          "storage": "âœ… T2_009 migrate_v12",
          "read_function": "âœ… T2_008 is_scan_cache_enabled()",
          "write_function": "âœ… T2_008 set_scan_cache_enabled()"
        }
      ]
    }
  },
  "templates": [
    {
      "template_id": "T2_001",
      "name": "SessionMetadata ç»“æ„ä½“",
      "purpose": "ä¼šè¯å…ƒæ•°æ®ç»“æ„ï¼Œç”¨äºæ‰«æå™¨è¿”å›ï¼ŒåŒ…å«å®Œæ•´çš„ from_path() æ–¹æ³•å®ç°",
      "file": "src-tauri/src/monitor/scanner.rs",
      "code": "\nuse serde::{Serialize, Deserialize};\nuse std::path::{Path, PathBuf};\nuse std::fs;\nuse anyhow::{Result, Context};\n\n/// ä¼šè¯å…ƒæ•°æ®\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionMetadata {\n    pub session_id: String,\n    pub project_path: String,\n    pub project_name: String,\n    pub file_path: PathBuf,\n    pub created_at: String,\n    pub updated_at: String,\n    pub message_count: usize,\n    pub is_active: bool,\n}\n\nimpl SessionMetadata {\n    /// ä»æ–‡ä»¶è·¯å¾„æå–ä¼šè¯å…ƒæ•°æ®ï¼ˆå®Œæ•´å®ç°ï¼‰\n    pub fn from_path(path: &Path) -> Result<Self> {\n        let file_name = path.file_name()\n            .and_then(|n| n.to_str())\n            .ok_or_else(|| anyhow::anyhow!(\"æ— æ•ˆçš„æ–‡ä»¶å: {:?}\", path))?;\n\n        if !file_name.ends_with(\".jsonl\") {\n            return Err(anyhow::anyhow!(\"æ–‡ä»¶ä¸æ˜¯ JSONL æ ¼å¼: {}\", file_name));\n        }\n\n        let session_id = file_name.strip_suffix(\".jsonl\")\n            .ok_or_else(|| anyhow::anyhow!(\"æ— æ³•å»æ‰ .jsonl æ‰©å±•å\"))?;\n\n        let path_str = path.to_str()\n            .ok_or_else(|| anyhow::anyhow!(\"è·¯å¾„æ— æ³•è½¬æ¢ä¸ºå­—ç¬¦ä¸²\"))?;\n\n        let projects_part = path_str.rfind(\".claude\")\n            .and_then(|pos| path_str[pos..].find(\"projects\"))\n            .ok_or_else(|| anyhow::anyhow!(\"è·¯å¾„ä¸åŒ…å« .claude/projects/\"))?;\n\n        let after_projects = &path_str[projects_part + \"projects\".len()..];\n        let parts: Vec<&str> = after_projects\n            .trim_start_matches('/')\n            .trim_start_matches('\\\\')\n            .split(['/', '\\\\'])\n            .collect();\n\n        if parts.len() < 2 {\n            return Err(anyhow::anyhow!(\"è·¯å¾„ç»“æ„ä¸ç¬¦åˆé¢„æœŸ: {:?}\", parts));\n        }\n\n        let project_name = parts[0].to_string();\n        let project_path = format!(\n            \"{}.claude/projects/{}\",\n            std::env::var(\"HOME\").or_else(|_| std::env::var(\"USERPROFILE\"))?,\n            project_name\n        );\n\n        let metadata = fs::metadata(path)\n            .with_context(|| format!(\"æ— æ³•è¯»å–æ–‡ä»¶å…ƒæ•°æ®: {:?}\", path))?;\n\n        let created_at = metadata.created()\n            .ok()\n            .and_then(|t| {\n                let secs = t.duration_since(std::time::UNIX_EPOCH).ok()?.as_secs();\n                Some(format!(\"{}\", secs))\n            })\n            .unwrap_or_else(|| \"0\".to_string());\n\n        let updated_at = metadata.modified()\n            .ok()\n            .and_then(|t| {\n                let secs = t.duration_since(std::time::UNIX_EPOCH).ok()?.as_secs();\n                Some(format!(\"{}\", secs))\n            })\n            .unwrap_or_else(|| \"0\".to_string());\n\n        let message_count = fs::read_to_string(path)\n            .map(|content| content.lines().count())\n            .unwrap_or(0);\n\n        Ok(Self {\n            session_id: session_id.to_string(),\n            project_path,\n            project_name,\n            file_path: path.to_path_buf(),\n            created_at,\n            updated_at,\n            message_count,\n            is_active: false,\n        })\n    }\n}\n",
      "dependencies": ["serde", "anyhow", "std::fs", "std::path"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯",
        "srg_check": "æ‰€æœ‰ç¬¦å·å®šä¹‰å®Œæ•´"
      }
    },
    {
      "template_id": "T2_002",
      "name": "Tauri Command - scan_sessions",
      "purpose": "æš´éœ²ç»™å‰ç«¯çš„ä¼šè¯æ‰«æå‘½ä»¤ï¼Œå®Œæ•´çš„å‘½ä»¤å®ç°",
      "file": "src-tauri/src/commands.rs",
      "code": "\nuse tauri::State;\nuse crate::llm::manager::LLMClientManager;\nuse crate::monitor::scanner;\nuse crate::database::repository::SessionRepository;\nuse crate::database::models::SessionMeta;\nuse crate::commands::CommandError;\n\n#[tauri::command]\npub async fn scan_sessions(\n    manager: State<'_, LLMClientManager>,\n) -> Result<Vec<SessionMeta>, CommandError> {\n    let conn = manager.get_conn()\n        .map_err(|e| CommandError {\n            message: format!(\"è·å–æ•°æ®åº“è¿æ¥å¤±è´¥: {}\", e)\n        })?;\n\n    let sessions = scanner::scan_session_files()\n        .map_err(|e| CommandError {\n            message: format!(\"æ‰«æä¼šè¯æ–‡ä»¶å¤±è´¥: {}\", e)\n        })?;\n\n    let repo = SessionRepository::new(conn);\n    let mut result = Vec::new();\n    for metadata in sessions {\n        let session = repo.upsert_session(&metadata)\n            .map_err(|e| CommandError {\n                message: format!(\"å­˜å‚¨ä¼šè¯å¤±è´¥: {}\", e)\n            })?;\n\n        result.push(SessionMeta {\n            sessionId: session.session_id,\n            projectPath: session.project_path,\n            projectName: session.project_name,\n            createdAt: session.created_at,\n            updatedAt: session.updated_at,\n            messageCount: session.message_count,\n            isActive: session.is_active,\n        });\n    }\n\n    Ok(result)\n}\n",
      "dependencies": ["tauri"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯",
        "note": "éœ€è¦ T2_010 (SessionRepository::upsert_session)"
      }
    },
    {
      "template_id": "T2_003",
      "name": "æ•°æ®åº“è¿ç§» v9 - æ‰©å±• sessions è¡¨",
      "purpose": "æ·»åŠ  rating, tags, is_archived å­—æ®µ",
      "file": "src-tauri/src/database/migrations.rs",
      "code": "\nuse rusqlite::{Connection, Result};\nuse crate::database::migrations::update_schema_version;\n\npub fn migrate_v9(conn: &mut Connection) -> Result<()> {\n    conn.execute(\n        \"ALTER TABLE sessions ADD COLUMN rating INTEGER DEFAULT 0;\",\n        [],\n    )?;\n\n    conn.execute(\n        \"ALTER TABLE sessions ADD COLUMN tags TEXT;\",\n        [],\n    )?;\n\n    conn.execute(\n        \"ALTER TABLE sessions ADD COLUMN is_archived INTEGER DEFAULT 0;\",\n        [],\n    )?;\n\n    update_schema_version(conn, 9)?;\n    Ok(())\n}\n",
      "dependencies": ["rusqlite"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯"
      }
    },
    {
      "template_id": "T2_004",
      "name": "æ•°æ®åº“è¿ç§» v10 - åˆ›å»º saved_prompts è¡¨",
      "purpose": "å­˜å‚¨ç”¨æˆ·ä¿å­˜çš„æç¤ºè¯",
      "file": "src-tauri/src/database/migrations.rs",
      "code": "\nuse rusqlite::{Connection, Result};\nuse crate::database::migrations::update_schema_version;\n\npub fn migrate_v10(conn: &mut Connection) -> Result<()> {\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS saved_prompts (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL,\n            content TEXT NOT NULL,\n            category TEXT,\n            created_at TEXT NOT NULL DEFAULT (datetime('now')),\n            updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n        );\",\n        [],\n    )?;\n\n    conn.execute(\n        \"CREATE INDEX IF NOT EXISTS idx_saved_prompts_category\n         ON saved_prompts(category);\",\n        [],\n    )?;\n\n    update_schema_version(conn, 10)?;\n    Ok(())\n}\n",
      "dependencies": ["rusqlite"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯"
      }
    },
    {
      "template_id": "T2_005",
      "name": "æ•°æ®åº“è¿ç§» v11 - åˆ›å»º meta_templates è¡¨",
      "purpose": "å­˜å‚¨ç³»ç»Ÿæç¤ºè¯æ¨¡æ¿",
      "file": "src-tauri/src/database/migrations.rs",
      "code": "\nuse rusqlite::{Connection, Result};\nuse crate::database::migrations::update_schema_version;\n\npub fn migrate_v11(conn: &mut Connection) -> Result<()> {\n    conn.execute(\n        \"CREATE TABLE IF NOT EXISTS meta_templates (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT NOT NULL UNIQUE,\n            description TEXT,\n            template_content TEXT NOT NULL,\n            category TEXT,\n            version TEXT DEFAULT '1.0',\n            is_active INTEGER DEFAULT 1,\n            created_at TEXT NOT NULL DEFAULT (datetime('now')),\n            updated_at TEXT NOT NULL DEFAULT (datetime('now'))\n        );\",\n        [],\n    )?;\n\n    conn.execute(\n        \"CREATE INDEX IF NOT EXISTS idx_meta_templates_category\n         ON meta_templates(category);\",\n        [],\n    )?;\n\n    conn.execute(\n        \"CREATE INDEX IF NOT EXISTS idx_meta_templates_active\n         ON meta_templates(is_active);\",\n        [],\n    )?;\n\n    update_schema_version(conn, 11)?;\n    Ok(())\n}\n",
      "dependencies": ["rusqlite"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯"
      }
    },
    {
      "template_id": "T2_006",
      "name": "æ€§èƒ½æµ‹è¯•æ¡†æ¶",
      "purpose": "åŸºå‡†æµ‹è¯•åŸºç¡€è®¾æ–½ï¼ŒåŒ…å«å®Œæ•´çš„æµ‹è¯•è¾…åŠ©å‡½æ•°å®ç°",
      "file": "src-tauri/tests/performance.rs",
      "code": "\n#[cfg(test)]\nmod performance_tests {\n    use super::*;\n    use std::time::Instant;\n    use std::fs::{self, File};\n    use std::path::PathBuf;\n\n    fn setup_test_environment() -> Vec<PathBuf> {\n        let home = std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap();\n\n        let projects_dir = PathBuf::from(home).join(\".claude/projects\");\n        let mut created_files = Vec::new();\n\n        for i in 0..10 {\n            let project_dir = projects_dir.join(format!(\"test-project-{}\", i));\n            fs::create_dir_all(&project_dir).unwrap();\n\n            for j in 0..10 {\n                let file_path = project_dir.join(format!(\n                    \"{:04x}{:04x}-{:04x}-{:04x}-{:04x}{:04x}{:04x}.jsonl\",\n                    i, i, j, j, i, j, i + j\n                ));\n\n                let mut file = File::create(&file_path).unwrap();\n\n                for k in 0..10 {\n                    writeln!(\n                        file,\n                        \"{{\\\"role\\\": \\\"user\\\", \\\"content\\\": \\\"Test message {} from project {} session {}\\\"}}\",\n                        k, i, j\n                    ).unwrap();\n                }\n\n                created_files.push(file_path);\n            }\n        }\n\n        created_files\n    }\n\n    fn cleanup_test_environment(files: Vec<PathBuf>) {\n        let home = std::env::var(\"HOME\")\n            .or_else(|_| std::env::var(\"USERPROFILE\"))\n            .unwrap();\n\n        let projects_dir = PathBuf::from(home).join(\".claude/projects\");\n\n        if let Ok(entries) = fs::read_dir(&projects_dir) {\n            for entry in entries.flatten() {\n                let path = entry.path();\n                if let Some(name) = path.file_name() {\n                    if to_string!(name).starts_with(\"test-project-\") {\n                        let _ = fs::remove_dir_all(&path);\n                    }\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn test_startup_time() {\n        let start = Instant::now();\n        let _conn = crate::database::establish_connection().unwrap();\n        let _config = crate::config::load_config().unwrap();\n        let duration = start.elapsed();\n        assert!(\n            duration.as_secs() < 3,\n            \"å¯åŠ¨æ—¶é—´è¶…æ ‡: {:?} (ç›®æ ‡ < 3s)\",\n            duration\n        );\n    }\n\n    #[test]\n    fn test_session_scan_time_100() {\n        let created_files = setup_test_environment();\n        let start = Instant::now();\n        let sessions = crate::monitor::scanner::scan_session_files().unwrap();\n        let duration = start.elapsed();\n        cleanup_test_environment(created_files);\n        assert_eq!(\n            sessions.len(),\n            100,\n            \"åº”æ‰«æåˆ° 100 ä¸ªä¼šè¯ï¼Œå®é™…: {}\",\n            sessions.len()\n        );\n        assert!(\n            duration.as_secs() < 2,\n            \"æ‰«ææ—¶é—´è¶…æ ‡: {:?} (ç›®æ ‡ < 2s)\",\n            duration\n        );\n    }\n}\n",
      "dependencies": ["std::time::Instant", "std::fs"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯"
      }
    },
    {
      "template_id": "T2_007",
      "name": "Session è¾…åŠ©æ–¹æ³• - tags åºåˆ—åŒ–",
      "purpose": "tags å­—æ®µçš„åºåˆ—åŒ–/ååºåˆ—åŒ–æ–¹æ³•",
      "file": "src-tauri/src/database/models.rs",
      "code": "\nuse serde_json;\nuse anyhow::{Result, anyhow};\n\nimpl Session {\n    pub fn get_tags(&self) -> Result<Vec<String>> {\n        self.tags.as_ref()\n            .map(|s| serde_json::from_str(s))\n            .unwrap_or(Ok(vec![]))\n            .map_err(|e| anyhow!(\"æ ‡ç­¾è§£æå¤±è´¥: {}\", e))\n    }\n\n    pub fn set_tags(&mut self, tags: Vec<String>) -> Result<()> {\n        self.tags = Some(serde_json::to_string(&tags)?);\n        Ok(())\n    }\n\n    pub fn add_tag(&mut self, tag: String) -> Result<()> {\n        let mut tags = self.get_tags()?;\n        if !tags.contains(&tag) {\n            tags.push(tag);\n            self.set_tags(tags)?;\n        }\n        Ok(())\n    }\n\n    pub fn remove_tag(&mut self, tag: &str) -> Result<()> {\n        let mut tags = self.get_tags()?;\n        tags.retain(|t| t != tag);\n        self.set_tags(tags)\n    }\n}\n",
      "dependencies": ["serde_json"],
      "_v6_0_notes": {
        "status": "âœ… å·²éªŒè¯"
      }
    },
    {
      "template_id": "T2_008",
      "name": "Settings æ¨¡å— - è¯»å†™å‡½æ•°",
      "purpose": "v6.0 æ–°å¢ï¼šæä¾› settings è¡¨çš„è¯»å†™å‡½æ•°ï¼Œä¿®å¤ç¬¦å·å­¤å²›é—®é¢˜",
      "file": "src-tauri/src/database/settings.rs",
      "code": "\n//! Settings æ¨¡å— - åº”ç”¨çº§é…ç½®ç®¡ç†\n//!\n//! æä¾› settings è¡¨çš„ CRUD æ“ä½œï¼ŒåŒ…æ‹¬ï¼š\n//! - active_threshold: æ´»è·ƒåˆ¤æ–­æ—¶é—´é˜ˆå€¼\n//! - scan_cache_enabled: æ‰«æç¼“å­˜å¯ç”¨çŠ¶æ€\n\nuse rusqlite::{Connection, Result};\nuse anyhow::anyhow;\n\n/// è¯»å–æ´»è·ƒé˜ˆå€¼é…ç½®\n///\n/// # Returns\n/// - `Ok(u64)`: æ´»è·ƒé˜ˆå€¼ï¼ˆç§’ï¼‰\n/// - `Err(anyhow::Error)`: è¯»å–å¤±è´¥\n///\n/// # Example\n/// ```no_run\n/// let conn = establish_connection().unwrap();\n/// let threshold = get_active_threshold(&conn).unwrap_or(86400);\n/// ```\npub fn get_active_threshold(conn: &Connection) -> Result<u64> {\n    conn.query_row(\n        \"SELECT active_threshold FROM settings WHERE id = 1\",\n        [],\n        |row| row.get(0)\n    ).map_err(|e| anyhow!(\"è¯»å–æ´»è·ƒé˜ˆå€¼å¤±è´¥: {}\", e))\n}\n\n/// æ›´æ–°æ´»è·ƒé˜ˆå€¼é…ç½®\n///\n/// # Arguments\n/// - `conn`: æ•°æ®åº“è¿æ¥\n/// - `value`: æ–°çš„é˜ˆå€¼ï¼ˆç§’ï¼‰\n///\n/// # Returns\n/// - `Ok(())`: æ›´æ–°æˆåŠŸ\n/// - `Err(anyhow::Error)`: æ›´æ–°å¤±è´¥\npub fn update_active_threshold(conn: &Connection, value: u64) -> Result<()> {\n    conn.execute(\n        \"UPDATE settings SET active_threshold = ? WHERE id = 1\",\n        [value]\n    ).map_err(|e| anyhow!(\"æ›´æ–°æ´»è·ƒé˜ˆå€¼å¤±è´¥: {}\", e))?;\n    Ok(())\n}\n\n/// è¯»å–æ‰«æç¼“å­˜å¯ç”¨çŠ¶æ€\n///\n/// # Returns\n/// - `Ok(bool)`: true è¡¨ç¤ºå¯ç”¨ç¼“å­˜\n/// - `Err(anyhow::Error)`: è¯»å–å¤±è´¥\npub fn is_scan_cache_enabled(conn: &Connection) -> Result<bool> {\n    let value: i64 = conn.query_row(\n        \"SELECT scan_cache_enabled FROM settings WHERE id = 1\",\n        [],\n        |row| row.get(0)\n    ).map_err(|e| anyhow!(\"è¯»å–ç¼“å­˜çŠ¶æ€å¤±è´¥: {}\", e))?;\n    Ok(value == 1)\n}\n\n/// è®¾ç½®æ‰«æç¼“å­˜å¯ç”¨çŠ¶æ€\n///\n/// # Arguments\n/// - `conn`: æ•°æ®åº“è¿æ¥\n/// - `enabled`: true å¯ç”¨ï¼Œfalse ç¦ç”¨\n///\n/// # Returns\n/// - `Ok(())`: æ›´æ–°æˆåŠŸ\n/// - `Err(anyhow::Error)`: æ›´æ–°å¤±è´¥\npub fn set_scan_cache_enabled(conn: &Connection, enabled: bool) -> Result<()> {\n    let enabled_int = if enabled { 1 } else { 0 };\n    conn.execute(\n        \"UPDATE settings SET scan_cache_enabled = ? WHERE id = 1\",\n        [enabled_int]\n    ).map_err(|e| anyhow!(\"è®¾ç½®ç¼“å­˜çŠ¶æ€å¤±è´¥: {}\", e))?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_get_active_threshold() {\n        let conn = crate::database::establish_connection().unwrap();\n        let threshold = get_active_threshold(&conn).unwrap();\n        assert_eq!(threshold, 86400); // é»˜è®¤å€¼\n    }\n\n    #[test]\n    fn test_update_active_threshold() {\n        let conn = crate::database::establish_connection().unwrap();\n        update_active_threshold(&conn, 3600).unwrap();\n        let threshold = get_active_threshold(&conn).unwrap();\n        assert_eq!(threshold, 3600);\n        // æ¢å¤é»˜è®¤å€¼\n        update_active_threshold(&conn, 86400).unwrap();\n    }\n\n    #[test]\n    fn test_scan_cache_enabled() {\n        let conn = crate::database::establish_connection().unwrap();\n        let enabled = is_scan_cache_enabled(&conn).unwrap();\n        assert!(enabled); // é»˜è®¤å¯ç”¨\n    }\n}\n",
      "dependencies": ["rusqlite", "anyhow"],
      "_v6_0_notes": {
        "status": "ğŸ†• v6.0 æ–°å¢",
        "fixes": [
          "ç¬¦å·å­¤å²›: get_active_threshold()",
          "ç¬¦å·å­¤å²›: update_active_threshold()",
          "ç¬¦å·å­¤å²›: is_scan_cache_enabled()",
          "ç¬¦å·å­¤å²›: set_scan_cache_enabled()"
        ],
        "configuration_closure": {
          "active_threshold": "âœ… é—­ç¯å®Œæ•´ (å®šä¹‰ + å­˜å‚¨ + è¯»å– + å†™å…¥)",
          "scan_cache_enabled": "âœ… é—­ç¯å®Œæ•´ (å®šä¹‰ + å­˜å‚¨[T2_009] + è¯»å– + å†™å…¥)"
        }
      }
    },
    {
      "template_id": "T2_009",
      "name": "æ•°æ®åº“è¿ç§» v12 - æ·»åŠ  settings è¡¨æ‰©å±•å­—æ®µ",
      "purpose": "v6.0 æ–°å¢ï¼šæ·»åŠ  scan_cache_enabled å­—æ®µåˆ° settings è¡¨ï¼Œå®Œæˆé…ç½®é—­ç¯",
      "file": "src-tauri/src/database/migrations.rs",
      "code": "\nuse rusqlite::{Connection, Result};\nuse crate::database::migrations::update_schema_version;\n\n/// è¿ç§» v12: æ‰©å±• settings è¡¨ï¼Œæ·»åŠ æ‰«æç¼“å­˜é…ç½®\n///\n/// # åŠŸèƒ½\n/// - scan_cache_enabled: æ‰«æç¼“å­˜å¯ç”¨çŠ¶æ€ï¼ˆé»˜è®¤å¯ç”¨ï¼‰\n///\n/// # ä¾èµ–\n/// - Wave 1 çš„ migrate_v6 å¿…é¡»å·²åˆ›å»º settings è¡¨\n///\n/// # å›æ»š\n/// ```sql\n/// ALTER TABLE settings DROP COLUMN scan_cache_enabled;\n/// ```\npub fn migrate_v12(conn: &mut Connection) -> Result<()> {\n    // æ£€æŸ¥å­—æ®µæ˜¯å¦å·²å­˜åœ¨\n    let column_exists: bool = conn.query_row(\n        \"SELECT COUNT(*) FROM pragma_table_info('settings') WHERE name='scan_cache_enabled'\",\n        [],\n        |row| row.get::<_, i64>(0).map(|c| c > 0)\n    ).unwrap_or(false);\n\n    if column_exists {\n        eprintln!(\"è­¦å‘Š: scan_cache_enabled å­—æ®µå·²å­˜åœ¨ï¼Œè·³è¿‡è¿ç§»\");\n        return Ok(());\n    }\n\n    // æ·»åŠ  scan_cache_enabled å­—æ®µï¼ˆé»˜è®¤å¯ç”¨ï¼š1ï¼‰\n    conn.execute(\n        \"ALTER TABLE settings ADD COLUMN scan_cache_enabled INTEGER DEFAULT 1;\",\n        [],\n    )?;\n\n    update_schema_version(conn, 12)?;\n\n    eprintln!(\"âœ… migrate_v12 å®Œæˆ: scan_cache_enabled å­—æ®µå·²æ·»åŠ \");\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_migrate_v12() {\n        let mut conn = crate::database::establish_test_connection().unwrap();\n        migrate_v12(&mut conn).unwrap();\n\n        // éªŒè¯å­—æ®µå­˜åœ¨\n        let column_exists: bool = conn.query_row(\n            \"SELECT COUNT(*) FROM pragma_table_info('settings') WHERE name='scan_cache_enabled'\",\n            [],\n            |row| row.get::<_, i64>(0).map(|c| c > 0)\n        ).unwrap();\n        assert!(column_exists, \"scan_cache_enabled å­—æ®µåº”å­˜åœ¨\");\n\n        // éªŒè¯é»˜è®¤å€¼\n        let enabled: i64 = conn.query_row(\n            \"SELECT scan_cache_enabled FROM settings WHERE id = 1\",\n            [],\n            |row| row.get(0)\n        ).unwrap();\n        assert_eq!(enabled, 1, \"é»˜è®¤å€¼åº”ä¸º 1 (å¯ç”¨)\");\n    }\n}\n",
      "dependencies": ["rusqlite"],
      "_v6_0_notes": {
        "status": "ğŸ†• v6.0 æ–°å¢",
        "fixes": [
          "é…ç½®é—­ç¯ç¼ºå£: scan_cache_enabled å­˜å‚¨ä½ç½®",
          "çŠ¶æ€æ¨¡ç³Šé—®é¢˜: æ˜ç¡®åœ¨ Wave 2 ä¸­åˆ›å»ºæ­¤å­—æ®µ"
        ],
        "integration_point": {
          "before": "åœ¨ wave2.3_task_t1_3.json ä¸­æ·»åŠ  Step 6",
          "after": "åœ¨ run_migrations() ä¸­è°ƒç”¨ migrate_v12"
        }
      }
    },
    {
      "template_id": "T2_010",
      "name": "SessionRepository - upsert_session æ–¹æ³•",
      "purpose": "v6.0 æ–°å¢ï¼šæä¾› SessionRepository çš„ upsert_session æ–¹æ³•å®ç°",
      "file": "src-tauri/src/database/repository.rs",
      "code": "\nuse rusqlite::{Connection, Result, params};\nuse anyhow::anyhow;\nuse crate::database::models::{Session, SessionMetadata};\n\nimpl SessionRepository {\n    /// Upsert ä¼šè¯ï¼šå¦‚æœå­˜åœ¨åˆ™æ›´æ–°ï¼Œå¦åˆ™åˆ›å»º\n    ///\n    /// # Arguments\n    /// - `metadata`: ä¼šè¯å…ƒæ•°æ®ï¼ˆä»æ‰«æå™¨è·å–ï¼‰\n    ///\n    /// # Returns\n    /// - `Ok(Session)`: Upsert åçš„ä¼šè¯å¯¹è±¡\n    /// - `Err(anyhow::Error)`: æ•°æ®åº“æ“ä½œå¤±è´¥\n    ///\n    /// # Behavior\n    /// 1. æ£€æŸ¥ session_id æ˜¯å¦å·²å­˜åœ¨\n    /// 2. å¦‚æœå­˜åœ¨ï¼Œæ›´æ–° updated_at å’Œ is_active\n    /// 3. å¦‚æœä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°è®°å½•\n    /// 4. è§¦å‘æ´»è·ƒçŠ¶æ€æ›´æ–°ï¼ˆè§¦å‘å™¨è‡ªåŠ¨å¤„ç†ï¼‰\n    pub fn upsert_session(&self, metadata: &SessionMetadata) -> Result<Session> {\n        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨\n        let existing = self.get_session_by_sid(&metadata.session_id);\n\n        let session = match existing {\n            Ok(mut sess) => {\n                // æ›´æ–°ç°æœ‰ä¼šè¯\n                sess.updated_at = metadata.updated_at.clone();\n                sess.is_active = metadata.is_active;\n                sess.message_count = metadata.message_count;\n                self.update_session(sess.id.unwrap(), &sess)?;\n                sess\n            }\n            Err(_) => {\n                // åˆ›å»ºæ–°ä¼šè¯\n                let new_session = Session {\n                    id: None,\n                    session_id: metadata.session_id.clone(),\n                    project_path: metadata.project_path.clone(),\n                    project_name: metadata.project_name.clone(),\n                    rating: 0,\n                    tags: None,\n                    is_archived: false,\n                    is_active: metadata.is_active,\n                    created_at: metadata.created_at.clone(),\n                    updated_at: metadata.updated_at.clone(),\n                    message_count: metadata.message_count,\n                };\n                self.create_session(&new_session)?\n            }\n        };\n\n        Ok(session)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_upsert_session_create() {\n        let conn = crate::database::establish_test_connection().unwrap();\n        let repo = SessionRepository::new(conn);\n\n        let metadata = SessionMetadata {\n            session_id: \"test-session-123\".to_string(),\n            project_path: \"/test/project\".to_string(),\n            project_name: \"test-project\".to_string(),\n            file_path: std::path::PathBuf::from(\"/test/test.jsonl\"),\n            created_at: \"1234567890\".to_string(),\n            updated_at: \"1234567890\".to_string(),\n            message_count: 10,\n            is_active: true,\n        };\n\n        let session = repo.upsert_session(&metadata).unwrap();\n        assert_eq!(session.session_id, \"test-session-123\");\n    }\n\n    #[test]\n    fn test_upsert_session_update() {\n        let conn = crate::database::establish_test_connection().unwrap();\n        let repo = SessionRepository::new(conn);\n\n        // ç¬¬ä¸€æ¬¡åˆ›å»º\n        let metadata1 = SessionMetadata {\n            session_id: \"test-session-456\".to_string(),\n            project_path: \"/test/project\".to_string(),\n            project_name: \"test-project\".to_string(),\n            file_path: std::path::PathBuf::from(\"/test/test.jsonl\"),\n            created_at: \"1234567890\".to_string(),\n            updated_at: \"1234567890\".to_string(),\n            message_count: 10,\n            is_active: true,\n        };\n        repo.upsert_session(&metadata1).unwrap();\n\n        // ç¬¬äºŒæ¬¡æ›´æ–°\n        let metadata2 = SessionMetadata {\n            session_id: \"test-session-456\".to_string(),\n            updated_at: \"1234567900\".to_string(),\n            is_active: false,\n            ..metadata1\n        };\n        let session = repo.upsert_session(&metadata2).unwrap();\n        assert_eq!(session.updated_at, \"1234567900\");\n        assert_eq!(session.is_active, false);\n    }\n}\n",
      "dependencies": ["rusqlite", "anyhow"],
      "_v6_0_notes": {
        "status": "ğŸ†• v6.0 æ–°å¢",
        "fixes": [
          "å®ç°è½åœ°æ€§: SessionRepository::upsert_session æ–¹æ³•"
        ]
      }
    }
  ],
  "external_references": [
    {
      "name": "Rust å¹¶è¡Œå¤„ç† - Rayon",
      "url": "https://docs.rs/rayon/",
      "purpose": "å­¦ä¹ å¹¶è¡Œè¿­ä»£å™¨ä½¿ç”¨æ–¹æ³•"
    },
    {
      "name": "Tauri Command æ–‡æ¡£",
      "url": "https://tauri.app/v2/api/js/",
      "purpose": "ç†è§£ Tauri å‘½ä»¤å®šä¹‰å’Œè°ƒç”¨"
    },
    {
      "name": "SQLite è¯­æ³•å‚è€ƒ",
      "url": "https://www.sqlite.org/lang.html",
      "purpose": "SQL è¯­å¥å’Œ DDL è¯­æ³•"
    }
  ],
  "notes": [
    "æ‰€æœ‰ä»£ç æ¨¡æ¿éƒ½æ˜¯ Rust ä»£ç ",
    "æ¨¡æ¿ä¸­çš„ import/use è¯­å¥å·²åŒ…å«åœ¨å†…",
    "é”™è¯¯å¤„ç†ä½¿ç”¨ Result<T> å’Œ anyhow::Error",
    "åºåˆ—åŒ–ä½¿ç”¨ serde å’Œ serde_json",
    "v6.0 ç‰ˆæœ¬æ–°å¢ T2_008, T2_009, T2_010 æ¨¡æ¿ä¿®å¤ç¬¦å·å­¤å²›å’Œé…ç½®é—­ç¯é—®é¢˜"
  ],
  "_v6_0_summary": {
    "total_templates": 10,
    "new_templates_v6": ["T2_008", "T2_009", "T2_010"],
    "fixed_orphan_symbols": 4,
    "closed_configuration_loops": 2,
    "overall_srg_status": "âœ… æ‰€æœ‰ç¬¦å·å¼•ç”¨å®Œæ•´"
  }
}
